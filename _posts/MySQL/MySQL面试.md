#多表连接查询相关
![](img/sql-joins.png)
- 左连接(left join)
  - 返回包括左表中的所有记录和右表中连接字段相等的记录
- 右连接(right join)
  - 返回包括右表中的所有记录和左表中连接字段相等的记录
- 内连接(也称为等值连接,inner join)
  - 返回两个表中连接字段相等的行
- 全外连接(full join)
  - 返回左右表中的所有记录和左右表中连接字段相等的记录

#关于删除
- truncate table `表名`
  - 效率高于delete
  - 保留表的结构
  - 不能回滚
- delete from `表名`
  - 添加 where 即删除特定行,不添加where则全部行都删除
  - 可以回滚
- drop table `表名`
  - 效率最高
  - 将表完全删除,包括表的结构
  - 依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid
  - 不能回滚

#视图相关
- 创建视图:
  - `create view  视图名  as  select 字段名 from 表名;`
- 修改视图:
  - `alter view 视图名 as select 语句`
- 删除视图:
  - `drop view 视图名[,视图名…];`

#MyISAM与InnoDB的区别
- InnoDB支持事务，MyISAM不支持
  - 对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务
- InnoDB支持外键，而MyISAM不支持
  - 对一个包含外键的InnoDB表转为MYISAM会失败
- InnoDB是聚集索引,MyISAM是非聚集索引
  - InnoDB是聚集索引,使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。
  - MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。
- InnoDB不保存表的具体行数,MyISAM使用一个变量保存了整个表的行数
  - InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件)
- Innodb不支持全文索引，而MyISAM支持全文索引
  - 在涉及全文索引领域的查询效率上MyISAM速度更快高；PS：5.7以后的InnoDB支持全文索引了
- MyISAM表格可以被压缩后进行查询操作
- InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁
  -  InnoDB的行锁是实现在索引上的，而不是锁在物理行记录上。潜台词是，如果访问没有命中索引，也无法使用行锁，将要退化为表锁。
- InnoDB表必须有主键（用户没有指定的话会自己找或生产一个主键），而Myisam可以没有
- Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYI
  - Innodb：frm是表定义文件，ibd是数据文件
  - Myisam：frm是表定义文件，myd是数据文件，myi是索引文件

#MySQL锁
- yISAM和MEMORY存储引擎采用的是表级锁（table-level locking）
- BDB存储引擎采用的是页面锁（page-level locking），但也支持表级锁
- InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。 

##锁类型
- 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
- 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
- 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

##表级锁(MyISAM)
- 两种模式
  - 表共享锁（Table Read Lock）
  - 表独占写锁（Table Write Lock）
- 对MyISAM的读操作，不会阻塞其他用户对同一表请求，但会阻塞对同一表的写请求
- 对MyISAM的写操作，则会阻塞其他用户对同一表的读和写操作
- MyISAM表的读操作和写操作之间，以及写操作之间是串行的
- MyISAM表的读和写操作之间，以及写和写操作之间是串行的
  - 当一线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止

###MyISAM的并发插入
- MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值分别可以为0、1或2
- 当concurrent_insert设置为0时，不允许并发插入。
- 当concurrent_insert设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录。这也是MySQL的默认设置。
- 当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。

###MyISAM的锁调度
- 在MyISAM中,写锁优先级大于读锁
  - 当一个进程请求读锁,同时另一个进程请求写锁时,写进程获得锁
  - 当读请求先进入队列,而写请求后进入队列时,先进行写锁
- 所以在写入操作较多的情况下,可能造成读操作的阻塞,因此使用MyISAM的调度行为
  - 通过指定启动参数low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利。
  - 通过执行命令SET LOW_PRIORITY_UPDATES=1，使该连接发出的更新请求优先级降低。
  - 通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。

##InnoDB锁

####事务的ACID属性
- 原性性（Actomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。
- 一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以操持完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。
- 隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。
- 持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。

###并发事务的问题
- 更新丢失（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题——最后的更新覆盖了其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改保存其更改副本的编辑人员覆盖另一个编辑人员所做的修改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题
- 脏读（Dirty Reads）：一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读”。
- 不可重复读（Non-Repeatable Reads）：一个事务在读取某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。
- 幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。

###行锁
- 共享锁（s）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
- 排他锁（Ｘ）：允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。
- 为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。
  - 意向共享锁（IS）：事务打算给数据行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。
  - 意向排他锁（IX）：事务打算给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。
- 事务可以通过以下语句显式给记录集加共享锁或排他锁：
  - 共享锁（S）：`SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE`
  - 排他锁（X）：`SELECT * FROM table_name WHERE ... FOR UPDATE`
- 在没有索引的情况下，InnoDB只能使用表锁

###间隙锁（Next-Key锁）
- 当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙(GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制不是所谓的间隙锁（Next-Key锁）。
- 举例来说，假如emp表中只有101条记录，其empid的值分别是1,2,...,100,101，下面的SQL：
  - `SELECT * FROM emp WHERE empid > 100 FOR UPDATE`
- 是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。
- InnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求，对于上面的例子，要是不使用间隙锁，如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另一方面，是为了满足其恢复和复制的需要。有关其恢复和复制对机制的影响，以及不同隔离级别下InnoDB使用间隙锁的情况。
- 由于间隙锁的缘故,所以应尽量使用等于条件来访问更新数据

##封锁协议
- 在运用X锁和S锁对数据对象加锁时，还需要约定一些规则 ，例如何时申请X锁或S锁、持锁时间、何时释放等。称这些规则为封锁协议（Locking Protocol）。对封锁方式规定不同的规则，就形成了各种不同的封锁协议。不同的封锁协议，在不同的程度上为并发操作的正确调度提供一定的保证。
- 三级协议的主要区别在于什么操作需要申请封锁，以及何时释放。
 
###一级封锁协议
- 事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）。
- 一级封锁协议可以防止丢失修改，并保证事务T是可恢复的。使用一级封锁协议可以解决丢失修改问题。
- 在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，它不能保证可重复读和不读“脏”数据。
　　
###二级封锁协议
- 一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后方可释放S锁。
- 二级封锁协议除防止了丢失修改，还可以进一步防止读“脏”数据。但在二级封锁协议中，由于读完数据后即可释放S锁，所以它不能保证可重复读。

###三级封锁协议 
- 一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。
- 三级封锁协议除防止了丢失修改和不读“脏”数据外，还进一步防止了不可重复读。

#索引
- 使用B-TREE实现